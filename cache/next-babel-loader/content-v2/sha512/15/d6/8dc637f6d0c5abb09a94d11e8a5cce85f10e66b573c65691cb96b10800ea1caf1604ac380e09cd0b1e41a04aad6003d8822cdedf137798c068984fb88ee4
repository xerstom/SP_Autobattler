{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { generateFightCards } from \"../factory/CardFactory.js\";\nimport Manager from \"../Manager.js\";\nimport { CONFIG } from \"../utils/constants.js\";\nimport { rand } from \"../utils/utils.js\";\n\nvar BattleManager = /*#__PURE__*/function (_Manager) {\n  _inherits(BattleManager, _Manager);\n\n  var _super = _createSuper(BattleManager);\n\n  function BattleManager(gameManager) {\n    var _this;\n\n    _classCallCheck(this, BattleManager);\n\n    _this = _super.call(this, gameManager);\n    _this.ready = false;\n    _this.state = [];\n    /**\n    \t* agent1: agent1.name,\n    * agent2: agent2.name,\n    * summary,\n    * detailedCombat: combatDetails,\n    \t*/\n\n    _this.battles = [];\n    _this.fighters = [];\n    _this.damagePerCard = CONFIG.DAMAGE_PER_CARD;\n    _this.moneyPerFight = CONFIG.MONEY_PER_COMBAT;\n    return _this;\n  }\n\n  _createClass(BattleManager, [{\n    key: \"getMoneyBattle\",\n    value: function getMoneyBattle(agent, totalCards) {\n      if (totalCards === 0) {\n        return Math.round(this.moneyToSplit / 2);\n      }\n\n      return Math.round(this.moneyToSplit * (agent.board.length / totalCards));\n    }\n  }, {\n    key: \"init\",\n    value: function init() {//\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.ready = false;\n      this.state = [];\n      this.battles = [];\n      this.fighters = [];\n    }\n  }, {\n    key: \"summary\",\n    value: function summary() {\n      return this.state;\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this2 = this;\n\n      this.reset();\n      var all = this.m.getAgents();\n\n      var _iterator = _createForOfIteratorHelper(all),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var agent = _step.value;\n          // who will fight with the current agent\n          // includes the current agent + all that matches its position\n          var fighting = all.filter(function (e) {\n            return _this2.m.samePosition(e, agent) && !_this2.fighters.includes(e.name);\n          }); // add to current fighters\n\n          fighting.forEach(function (e) {\n            return _this2.fighters.push(e.name);\n          }); // everyone fight two by two (every combination)\n\n          for (var i = 0; i < fighting.length; ++i) {\n            for (var j = i + 1; j < fighting.length; ++j) {\n              // delay fights\n              _this2.battles.push([fighting[i], fighting[j]]);\n            }\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.ready = true;\n    }\n  }, {\n    key: \"battleAll\",\n    value: function battleAll() {\n      if (!this.ready) {\n        return;\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.battles),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var battle = _step2.value;\n          var agent1 = this.prepareBattle(battle[0]);\n          var agent2 = this.prepareBattle(battle[1]);\n          var combatDetails = this.battle(agent1, agent2);\n          var totalCards = agent1.board.length + agent2.board.length;\n          battle[0].increaseMoney(this.getMoneyBattle(agent1, totalCards));\n          battle[1].increaseMoney(this.getMoneyBattle(agent2, totalCards));\n          battle[0].decreaseLife(agent2.board.length * this.damagePerCard);\n          battle[1].decreaseLife(agent1.board.length * this.damagePerCard);\n          battle[0].increaseMoney(this.battleSalary);\n          battle[1].increaseMoney(this.battleSalary);\n          var summary = \"\".concat(agent1.name, \" a inflige \").concat(agent1.board.length * this.damagePerCard, \" degats a \").concat(agent2.name, \" et \").concat(agent2.name, \" a inflige \").concat(agent2.board.length * this.damagePerCard, \" degats a \").concat(agent1.name, \"!\");\n          this.state.push({\n            agent1: agent1.name,\n            agent2: agent2.name,\n            summary: summary,\n            detailedCombat: combatDetails\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"prepareBattle\",\n    value: function prepareBattle(agent) {\n      return {\n        name: agent.name,\n        board: generateFightCards(agent.board)\n      };\n    }\n    /**\n     *\n     *\n     * @param {Array<FightCard>} agent1 Board for Agent1\n     * @param {Array<FightCard>} agent2 Board for Agent2\n     * @return {Array<String>}\n     * @memberof CombatManager\n     */\n\n  }, {\n    key: \"battle\",\n    value: function battle(_ref, _ref2) {\n      var agent1Name = _ref.name,\n          agent1Board = _ref.board;\n      var agent2Name = _ref2.name,\n          agent2Board = _ref2.board;\n      var agent1Cur = 0;\n      var agent2Cur = 0;\n      var agent1Buf, agent2Buf, det;\n      var battleDetails = [];\n\n      while (agent1Board.length > 0 && agent2Board.length > 0 && (agent1Cur < agent1Board.length || agent2Cur < agent2Board.length)) {\n        var r = void 0;\n\n        if (agent1Cur === agent1Board.length) {\n          r = 1;\n        } else if (agent2Cur === agent2Board.length) {\n          r = 0;\n        } else {\n          r = rand(0, 1);\n        }\n\n        if (r === 0) {\n          // source = agent1\n          // target = agent2\n          var _this$fight = this.fight(agent1Name, agent2Name, agent1Board, agent2Board, agent1Cur, rand(0, agent2Board.length - 1), agent2Cur);\n\n          var _this$fight2 = _slicedToArray(_this$fight, 3);\n\n          agent1Buf = _this$fight2[0];\n          agent2Buf = _this$fight2[1];\n          det = _this$fight2[2];\n        } else {\n          // source = agent2\n          // target = agent1\n          var _this$fight3 = this.fight(agent2Name, agent1Name, agent2Board, agent1Board, agent2Cur, rand(0, agent1Board.length - 1), agent1Cur);\n\n          var _this$fight4 = _slicedToArray(_this$fight3, 3);\n\n          agent2Buf = _this$fight4[0];\n          agent1Buf = _this$fight4[1];\n          det = _this$fight4[2];\n        }\n\n        agent1Cur += agent1Buf;\n        agent2Cur += agent2Buf;\n        battleDetails.push(det);\n      }\n\n      return battleDetails;\n    }\n  }, {\n    key: \"fight\",\n    value: function fight(sourceName, targetName, sourceBoard, targetBoard, sourceIndex, targetIndex, targetCur) {\n      var sourceInd = 0;\n      var targetInd = 0;\n      targetBoard[targetIndex].life -= sourceBoard[sourceIndex].attack;\n      sourceBoard[sourceIndex].life -= targetBoard[targetIndex].attack;\n      var fightDetails = \"\".concat(sourceName, \"'s \").concat(sourceBoard[sourceIndex].displayName, \" attack \").concat(targetName, \"'s \").concat(targetBoard[targetIndex].displayName, \". \");\n      var isTargetDead = targetBoard[targetIndex].life <= 0;\n      var isSourceDead = sourceBoard[sourceIndex].life <= 0;\n\n      if (isTargetDead) {\n        targetBoard.splice(targetIndex, 1);\n        targetIndex < targetCur && --targetInd;\n\n        if (isSourceDead) {\n          fightDetails += \"They both killed each other.\";\n        } else {\n          fightDetails += \"The former killed the latter.\";\n        }\n      }\n\n      if (isSourceDead) {\n        sourceBoard.splice(sourceIndex, 1);\n\n        if (!isTargetDead) {\n          fightDetails += \"The latter killed the former.\";\n        }\n      } else {\n        sourceInd++;\n      }\n\n      return [sourceInd, targetInd, fightDetails];\n    }\n  }, {\n    key: \"battleSalary\",\n    get: function get() {\n      return Math.round(this.moneyPerFight / 4);\n    }\n  }, {\n    key: \"moneyToSplit\",\n    get: function get() {\n      return Math.round(this.moneyPerFight / 2);\n    }\n  }]);\n\n  return BattleManager;\n}(Manager);\n\nexport default BattleManager;","map":null,"metadata":{},"sourceType":"module"}