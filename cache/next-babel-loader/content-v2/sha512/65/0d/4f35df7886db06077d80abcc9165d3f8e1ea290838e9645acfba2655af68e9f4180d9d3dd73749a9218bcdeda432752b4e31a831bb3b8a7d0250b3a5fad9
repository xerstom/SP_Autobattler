{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport BackGameInterface from \"../core/BackGameInterface.js\"; // phase 1 => waiting for position\n// phase 2 => waiting for next turn\n\nclass FrontGameInterface {\n  constructor() {\n    this._backGameInterface = new BackGameInterface();\n    this.currentPhase = 2; // waiting for next turn\n\n    this.agentsPosition = [];\n    this.updatedAgentsPosition = [];\n  }\n\n  get bgi() {\n    return this._backGameInterface;\n  } // gameloop\n\n\n  start() {\n    this.bgi.start();\n    this.agentsPosition = this.bgi.getAgentsPosition();\n  }\n\n  next(selectedBox = null) {\n    if (this.currentPhase === 1 && !selectedBox) {\n      // phase = 1 => waiting for position => need selected position\n      return -1;\n    }\n\n    this.agentsPosition = this.bgi.getAgentsPosition();\n    const phase = this.bgi.next(selectedBox);\n    this.currentPhase = phase;\n    return phase;\n  } // position\n\n\n  getPriorAgentsPosition() {\n    this.updatedAgentsPosition = this.bgi.getPriorAgentsPosition();\n    return this.updatedAgentsPosition.length;\n  }\n\n  getLaterAgentsPosition() {\n    this.updatedAgentsPosition = this.bgi.getLaterAgentsPosition();\n    return this.updatedAgentsPosition.length;\n  }\n\n  getAgentsPosition() {\n    return [...this.agentsPosition];\n  }\n\n  getUpdatedAgentsPosition() {\n    if (this.updatedAgentsPosition.length > 0) {\n      const uAgent = this.updatedAgentsPosition.shift();\n      const index = this.agentsPosition.findIndex(a => a.name === uAgent.name);\n      this.agentsPosition.splice(index, 1, uAgent);\n    } // return le cache\n\n\n    return this.getAgentsPosition();\n  } // PROFILE\n\n\n  getAgentsProfile() {\n    return [...this.bgi.getAgents()];\n  }\n\n  getProfile(agent) {\n    return _objectSpread({}, this.bgi.getAgent(agent));\n  }\n\n  getBoard(agent) {\n    return [...this.bgi.getBoard(agent).board];\n  }\n\n  getBench(agent) {\n    return [...this.bgi.getBoard(agent).bench];\n  }\n\n  getMarketCard() {\n    return _objectSpread({}, this.bgi.getMarketCard());\n  } // PLAYER INTERACTIONS\n\n\n  boardUp() {\n    return this.bgi.boardUp();\n  }\n\n  levelUp() {\n    return this.bgi.levelUp();\n  }\n\n  buyCard() {\n    return this.bgi.buyCard();\n  }\n\n  sellCard(index, location) {\n    return this.bgi.sellCard(index, location);\n  }\n\n  swapCard(index, location) {\n    return this.bgi.swapCard(index, location);\n  }\n\n  rerollCard() {\n    return this.bgi.rerollCard();\n  } // MAP\n\n\n  getGridSize() {\n    return this.bgi.getGridSize();\n  }\n\n  isSelectable(x, y) {\n    return this.bgi.canPlayerMove(x, y) && !this.isDisabled(x, y) && !this.willBeDisabled(x, y);\n  }\n\n  isDisabled(x, y) {\n    return this.bgi.isDisabled(x, y);\n  }\n\n  willBeDisabled(x, y) {\n    return this.bgi.willBeDisabled(x, y);\n  } // battle\n\n\n  getBattleSummary() {\n    return this.bgi.getBattleSummary().map(e => e.summary);\n  }\n\n  getLastCombat(agent) {\n    const sum = this.bgi.getBattleSummary();\n    const filtered = sum.filter(e => e.agent1 === agent || e.agent2 === agent);\n    return filtered.length > 0 ? filtered.pop() : null;\n  }\n\n}\n\nexport default FrontGameInterface;","map":null,"metadata":{},"sourceType":"module"}