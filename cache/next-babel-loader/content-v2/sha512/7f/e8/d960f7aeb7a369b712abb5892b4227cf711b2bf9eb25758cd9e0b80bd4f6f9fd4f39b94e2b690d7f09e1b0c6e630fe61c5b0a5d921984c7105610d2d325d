{"ast":null,"code":"import Manager from \"../Manager.js\";\nimport { CONFIG } from \"../utils/constants.js\";\nimport { absDistance, rand } from \"../utils/utils.js\";\n\nfunction generatePosition(borders) {\n  return rand(borders.x1, borders.x2);\n}\n\nclass PositionManager extends Manager {\n  constructor(gameManager) {\n    super(gameManager);\n    this.positions = new Map();\n    this.movementPoints = CONFIG.MOVEMENT_POINTS;\n  }\n\n  init() {\n    const agents = this.m.getAgents();\n\n    for (let i = 0; i < agents.length; i++) {\n      this.setPosition(agents[i].name, i, generatePosition(this.m.mapManager.borders));\n    }\n  }\n\n  getMovementPoints() {\n    return this.movementPoints;\n  }\n\n  setPosition(name, x, y) {\n    this.positions.set(name, {\n      name,\n      x,\n      y\n    });\n  }\n\n  getPosition(name) {\n    return this.positions.get(name);\n  }\n\n  getAllPosition() {\n    return [...this.positions.values()];\n  }\n\n  samePosition(a, b) {\n    const aPos = this.getPosition(a.name);\n    const bPos = this.getPosition(b.name);\n    return aPos.x === bPos.x && aPos.y === bPos.y;\n  } // TODO: verifier avec les borders?\n\n\n  canMove(name, x, y) {\n    const position = this.getPosition(name);\n    return Math.abs(x - position.x) + Math.abs(y - position.y) <= this.movementPoints;\n  }\n\n  moveBots(agents) {\n    for (const agent of agents) {\n      const newPos = agent.strategy.getPos(this, this.m.mapManager, agent);\n      this.move(agent, newPos);\n    }\n  }\n\n  move(agent, position) {\n    if (this.canMove(agent.name, position.x, position.y)) {\n      this.setPosition(agent.name, position.x, position.y);\n    }\n  }\n\n  getAgentsInRange(agent) {\n    return this.m.getPriorAgents(agent).filter(a => this.isInMoveDistance(a, agent));\n  }\n\n  isInMoveDistance(a, b) {\n    const aPos = this.getPosition(a.name);\n    const bPos = this.getPosition(b.name);\n    return absDistance(aPos.x, bPos.x) + absDistance(aPos.y, bPos.y) <= this.movementPoints;\n  }\n\n  getClosestPosition(srcPos, targetPos, mapManager) {\n    let xMove = srcPos.x < targetPos.x ? Math.round(this.movementPoints / 2) : -Math.round(this.movementPoints / 2);\n    xMove = this.reAdjustPosition(srcPos.x, targetPos.x, xMove); // Mp left to move\n\n    let mpLeft = this.movementPoints - Math.abs(xMove);\n    let yMove = srcPos.y < targetPos.y ? mpLeft : -mpLeft;\n    yMove = this.reAdjustPosition(srcPos.y, targetPos.y, yMove);\n    mpLeft = mpLeft - Math.abs(yMove) > 0 ? mpLeft : 0; // While we have mp to use\n\n    while (mpLeft > 0) {\n      // if we are not at the x pos\n      if (xMove + srcPos.x !== targetPos.x) {\n        xMove > 0 ? xMove++ : xMove--;\n        mpLeft--;\n      } else if (yMove + srcPos.y !== targetPos.y) {\n        // if we are not at the x pos\n        yMove > 0 ? yMove++ : yMove--;\n        mpLeft--;\n      } else {\n        // We are at the exact pos\n        break;\n      }\n    }\n\n    return {\n      x: srcPos.x + xMove,\n      y: srcPos.y + yMove\n    };\n  }\n\n  reAdjustPosition(curPos, posToGo, move) {\n    if (curPos < posToGo) {\n      // If we are left from the posToGo\n      if (curPos + move > posToGo) {\n        // If we went beyond posToGo\n        move = posToGo - curPos;\n      }\n    } else if (curPos - move < posToGo) {\n      // If we are right from the posToGo\n      // If we went beyond posToGo\n      move = curPos - posToGo;\n    }\n\n    return move;\n  }\n\n}\n\nexport default PositionManager;","map":null,"metadata":{},"sourceType":"module"}