{"ast":null,"code":"import { generateFightCards } from \"../factory/CardFactory.js\";\nimport Manager from \"../Manager.js\";\nimport { CONFIG } from \"../utils/constants.js\";\nimport { rand } from \"../utils/utils.js\";\n\nclass BattleManager extends Manager {\n  constructor(gameManager) {\n    super(gameManager);\n    this.ready = false;\n    this.state = [];\n    /**\n    \t* agent1: agent1.name,\n    * agent2: agent2.name,\n    * summary,\n    * detailedCombat: combatDetails,\n    \t*/\n\n    this.battles = [];\n    this.fighters = [];\n    this.damagePerCard = CONFIG.DAMAGE_PER_CARD;\n    this.moneyPerFight = CONFIG.MONEY_PER_COMBAT;\n  }\n\n  get battleSalary() {\n    return Math.round(this.moneyPerFight / 4);\n  }\n\n  get moneyToSplit() {\n    return Math.round(this.moneyPerFight / 2);\n  }\n\n  getMoneyBattle(agent, totalCards) {\n    if (totalCards === 0) {\n      return Math.round(this.moneyToSplit / 2);\n    }\n\n    return Math.round(this.moneyToSplit * (agent.board.length / totalCards));\n  }\n\n  init() {//\n  }\n\n  reset() {\n    this.ready = false;\n    this.state = [];\n    this.battles = [];\n    this.fighters = [];\n  }\n\n  summary() {\n    return this.state;\n  }\n\n  setup() {\n    this.reset();\n    const all = this.m.getAgents();\n\n    for (const agent of all) {\n      // who will fight with the current agent\n      // includes the current agent + all that matches its position\n      const fighting = all.filter(e => this.m.samePosition(e, agent) && !this.fighters.includes(e.name)); // add to current fighters\n\n      fighting.forEach(e => this.fighters.push(e.name)); // everyone fight two by two (every combination)\n\n      for (let i = 0; i < fighting.length; ++i) {\n        for (let j = i + 1; j < fighting.length; ++j) {\n          // delay fights\n          this.battles.push([fighting[i], fighting[j]]);\n        }\n      }\n    }\n\n    this.ready = true;\n  }\n\n  battleAll() {\n    if (!this.ready) {\n      return;\n    }\n\n    for (const battle of this.battles) {\n      const agent1 = this.prepareBattle(battle[0]);\n      const agent2 = this.prepareBattle(battle[1]);\n      const combatDetails = this.battle(agent1, agent2);\n      const totalCards = agent1.board.length + agent2.board.length;\n      battle[0].increaseMoney(this.getMoneyBattle(agent1, totalCards));\n      battle[1].increaseMoney(this.getMoneyBattle(agent2, totalCards));\n      battle[0].decreaseLife(agent2.board.length * this.damagePerCard);\n      battle[1].decreaseLife(agent1.board.length * this.damagePerCard);\n      battle[0].increaseMoney(this.battleSalary);\n      battle[1].increaseMoney(this.battleSalary);\n      const summary = `${agent1.name} a inflige ${agent1.board.length * this.damagePerCard} degats a ${agent2.name} et ${agent2.name} a inflige ${agent2.board.length * this.damagePerCard} degats a ${agent1.name}!`;\n      this.state.push({\n        agent1: agent1.name,\n        agent2: agent2.name,\n        summary,\n        detailedCombat: combatDetails\n      });\n    }\n  }\n\n  prepareBattle(agent) {\n    return {\n      name: agent.name,\n      board: generateFightCards(agent.board)\n    };\n  }\n  /**\n   *\n   *\n   * @param {Array<FightCard>} agent1 Board for Agent1\n   * @param {Array<FightCard>} agent2 Board for Agent2\n   * @return {Array<String>}\n   * @memberof CombatManager\n   */\n\n\n  battle({\n    name: agent1Name,\n    board: agent1Board\n  }, {\n    name: agent2Name,\n    board: agent2Board\n  }) {\n    let agent1Cur = 0;\n    let agent2Cur = 0;\n    let agent1Buf, agent2Buf, det;\n    const battleDetails = [];\n\n    while (agent1Board.length > 0 && agent2Board.length > 0 && (agent1Cur < agent1Board.length || agent2Cur < agent2Board.length)) {\n      let r;\n\n      if (agent1Cur === agent1Board.length) {\n        r = 1;\n      } else if (agent2Cur === agent2Board.length) {\n        r = 0;\n      } else {\n        r = rand(0, 1);\n      }\n\n      if (r === 0) {\n        // source = agent1\n        // target = agent2\n        [agent1Buf, agent2Buf, det] = this.fight(agent1Name, agent2Name, agent1Board, agent2Board, agent1Cur, rand(0, agent2Board.length - 1), agent2Cur);\n      } else {\n        // source = agent2\n        // target = agent1\n        [agent2Buf, agent1Buf, det] = this.fight(agent2Name, agent1Name, agent2Board, agent1Board, agent2Cur, rand(0, agent1Board.length - 1), agent1Cur);\n      }\n\n      agent1Cur += agent1Buf;\n      agent2Cur += agent2Buf;\n      battleDetails.push(det);\n    }\n\n    return battleDetails;\n  }\n\n  fight(sourceName, targetName, sourceBoard, targetBoard, sourceIndex, targetIndex, targetCur) {\n    let sourceInd = 0;\n    let targetInd = 0;\n    targetBoard[targetIndex].life -= sourceBoard[sourceIndex].attack;\n    sourceBoard[sourceIndex].life -= targetBoard[targetIndex].attack;\n    let fightDetails = `${sourceName}'s ${sourceBoard[sourceIndex].displayName} attack ${targetName}'s ${targetBoard[targetIndex].displayName}. `;\n    const isTargetDead = targetBoard[targetIndex].life <= 0;\n    const isSourceDead = sourceBoard[sourceIndex].life <= 0;\n\n    if (isTargetDead) {\n      targetBoard.splice(targetIndex, 1);\n      targetIndex < targetCur && --targetInd;\n\n      if (isSourceDead) {\n        fightDetails += \"They both killed each other.\";\n      } else {\n        fightDetails += \"The former killed the latter.\";\n      }\n    }\n\n    if (isSourceDead) {\n      sourceBoard.splice(sourceIndex, 1);\n\n      if (!isTargetDead) {\n        fightDetails += \"The latter killed the former.\";\n      }\n    } else {\n      sourceInd++;\n    }\n\n    return [sourceInd, targetInd, fightDetails];\n  }\n\n}\n\nexport default BattleManager;","map":null,"metadata":{},"sourceType":"module"}