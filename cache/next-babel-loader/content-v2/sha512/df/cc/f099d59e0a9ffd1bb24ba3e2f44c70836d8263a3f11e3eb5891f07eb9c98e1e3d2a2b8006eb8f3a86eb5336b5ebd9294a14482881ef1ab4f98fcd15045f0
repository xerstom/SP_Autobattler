{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Manager from \"../Manager.js\";\nimport { CONFIG } from \"../utils/constants.js\";\nimport { rand } from \"../utils/utils.js\";\n\nfunction generateNextBorders(border) {\n  var nextBorders = _objectSpread({}, border);\n\n  var xOry = rand(0, 1);\n  var oneOrTwo = rand(1, 2);\n  var toChange = \"\".concat(xOry === 0 ? \"x\" : \"y\").concat(oneOrTwo);\n  oneOrTwo === 1 ? nextBorders[toChange]++ : nextBorders[toChange]--;\n  return nextBorders;\n}\n\nvar MapManager = /*#__PURE__*/function (_Manager) {\n  _inherits(MapManager, _Manager);\n\n  var _super = _createSuper(MapManager);\n\n  function MapManager(gameManager) {\n    var _this;\n\n    _classCallCheck(this, MapManager);\n\n    _this = _super.call(this, gameManager);\n    _this.gridSize = CONFIG.GRID_SIZE;\n    _this.borders = {\n      x1: 0,\n      x2: _this.gridSize - 1,\n      y1: 0,\n      y2: _this.gridSize - 1\n    };\n    _this.nextBorders = generateNextBorders(_this.borders);\n    return _this;\n  }\n\n  _createClass(MapManager, [{\n    key: \"init\",\n    value: function init() {//\n    }\n  }, {\n    key: \"getGridSize\",\n    value: function getGridSize() {\n      return this.gridSize;\n    }\n  }, {\n    key: \"getBorders\",\n    value: function getBorders() {\n      return this.borders;\n    }\n  }, {\n    key: \"getNextBorders\",\n    value: function getNextBorders() {\n      return this.nextBorders;\n    }\n  }, {\n    key: \"generateNewBorders\",\n    value: function generateNewBorders() {\n      this.borders = this.nextBorders;\n      this.nextBorders = generateNextBorders(this.borders);\n    }\n  }, {\n    key: \"isOutsideBorders\",\n    value: function isOutsideBorders(x, y, borders) {\n      return x < borders.x1 || x > borders.x2 || y < borders.y1 || y > borders.y2;\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled(x, y) {\n      return this.isOutsideBorders(x, y, this.borders);\n    }\n  }, {\n    key: \"willBeDisabled\",\n    value: function willBeDisabled(x, y) {\n      return this.isOutsideBorders(x, y, this.nextBorders);\n    }\n  }, {\n    key: \"validPositions\",\n    value: function validPositions(agents) {\n      var _this2 = this;\n\n      return agents.filter(function (a) {\n        return !_this2.willBeDisabled(a.x, a.y);\n      });\n    }\n  }]);\n\n  return MapManager;\n}(Manager);\n\nexport default MapManager;","map":null,"metadata":{},"sourceType":"module"}